<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metasys UI Custom Symbol Builder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #5e72e4 0%, #825ee4 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }
        
        .tabs-nav {
            background: #f8f9fa;
            border-bottom: 2px solid #e0e0e0;
            display: flex;
            gap: 0;
            padding: 0 30px;
        }
        
        .tab-btn {
            padding: 15px 30px;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            color: #666;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .tab-btn:hover {
            background: rgba(94, 114, 228, 0.05);
        }
        
        .tab-btn.active {
            color: #5e72e4;
            border-bottom-color: #5e72e4;
            background: white;
        }
        
        .tab-content {
            display: none;
            padding: 30px;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .section h2 {
            color: #5e72e4;
            margin-bottom: 20px;
            font-size: 1.5em;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 500;
        }
        
        .form-group input[type="text"],
        .form-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        
        .form-group input[type="text"]:focus,
        .form-group select:focus {
            outline: none;
            border-color: #5e72e4;
        }
        
        .radio-group {
            display: flex;
            gap: 20px;
            margin-top: 10px;
        }
        
        .radio-group label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        
        .radio-group input[type="radio"] {
            margin-right: 8px;
        }
        
        .symbol-card {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .symbol-card h3 {
            color: #333;
            margin-bottom: 15px;
        }
        
        .file-input-group {
            margin-bottom: 15px;
        }
        
        .file-input-label {
            display: inline-block;
            padding: 8px 16px;
            background: #5e72e4;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .file-input-label:hover {
            background: #4c63d2;
        }
        
        .file-input {
            display: none;
        }
        
        .file-name {
            margin-left: 10px;
            color: #666;
            font-size: 14px;
        }
        
        .btn {
            padding: 12px 30px;
            font-size: 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #5e72e4 0%, #825ee4 100%);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(94, 114, 228, 0.3);
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
            margin-right: 10px;
        }
        
        .btn-success {
            background: #2dce89;
            color: white;
        }
        
        .animation-type {
            display: flex;
            gap: 20px;
            margin-top: 10px;
        }
        
        .state-inputs {
            margin-top: 15px;
        }
        
        .state-input-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .state-label {
            width: 100px;
            font-weight: 500;
        }
        
        #symbolsList {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .delete-btn {
            background: #f5365c;
            color: white;
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            float: right;
        }
        
        .progress {
            display: none;
            margin-top: 20px;
        }
        
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #5e72e4 0%, #825ee4 100%);
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Metasys UI Custom Symbol Builder</h1>
            <p>Create properly formatted custom symbol packages for Metasys UI</p>
        </div>
        
        <div class="tabs-nav">
            <button class="tab-btn active" onclick="switchTab('single')">Individual Symbols</button>
            <button class="tab-btn" onclick="switchTab('batch')">Batch Processing</button>
        </div>
        
        <!-- Single Symbol Tab -->
        <div id="singleTab" class="tab-content active">
            <!-- Package Configuration -->
            <div class="section">
                <h2>Package Configuration</h2>
                <div class="form-group">
                    <label>Package Structure:</label>
                    <div class="radio-group">
                        <label>
                            <input type="radio" name="structure" value="root" checked>
                            Root Level (Simple)
                        </label>
                        <label>
                            <input type="radio" name="structure" value="regions">
                            With Regions/Categories
                        </label>
                    </div>
                </div>
                
                <div id="regionsSection" style="display:none;">
                    <div class="form-group">
                        <label>Region/Category Names (comma-separated):</label>
                        <input type="text" id="regionNames" placeholder="e.g., Asia, Europe, Americas">
                    </div>
                </div>
            </div>
            
            <!-- Add Symbol -->
            <div class="section">
                <h2>Add Symbol</h2>
                <div class="symbol-card">
                    <div class="form-group">
                        <label>Symbol Name:</label>
                        <input type="text" id="symbolName" placeholder="e.g., WaterTankLarge">
                    </div>
                    
                    <div class="form-group" id="regionSelectGroup" style="display:none;">
                        <label>Region/Category:</label>
                        <select id="regionSelect">
                            <option value="">Select Region...</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>Animation Type:</label>
                        <div class="animation-type">
                            <label>
                                <input type="radio" name="animType" value="5state" checked>
                                5-State (0%, 25%, 50%, 75%, 100%)
                            </label>
                            <label>
                                <input type="radio" name="animType" value="binary">
                                Binary (On/Off)
                            </label>
                            <label>
                                <input type="radio" name="animType" value="static">
                                Static (No Animation)
                            </label>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label>Binding Point Name:</label>
                        <input type="text" id="pointName" placeholder="e.g., TankLevel">
                    </div>
                    
                    <div class="file-input-group">
                        <label class="file-input-label">
                            Choose Thumbnail (Optional)
                            <input type="file" class="file-input" id="thumbnail" accept="image/png">
                        </label>
                        <span class="file-name" id="thumbnailName"></span>
                        <div style="margin-top: 5px; font-size: 12px; color: #666;">
                            If not provided, thumbnail will be auto-generated from first frame
                        </div>
                    </div>
                    
                    <div id="stateInputs" class="state-inputs">
                        <!-- Dynamic state inputs will be added here -->
                    </div>
                    
                    <button class="btn btn-primary" onclick="addSymbol()">Add Symbol</button>
                </div>
            </div>
            
            <!-- Symbols List -->
            <div class="section">
                <h2>Symbols in Package</h2>
                <div id="symbolsList"></div>
            </div>
            
            <!-- Generate Package -->
            <div class="section">
                <button class="btn btn-success" onclick="generatePackage()" style="width: 100%; padding: 15px; font-size: 18px;">
                    Generate Package
                </button>
                <div class="progress" id="progress">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill">0%</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Batch Processing Tab -->
        <div id="batchTab" class="tab-content">
            <div class="section">
                <h2>Batch Folder Processing</h2>
                <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <h3 style="margin-top: 0; color: #1976d2;">How to Structure Your Folders:</h3>
                    <pre style="background: white; padding: 10px; border-radius: 4px; overflow-x: auto;">
RootFolder/
├── RegionName/           (optional - for regions)
│   ├── SymbolName1/
│   │   ├── frame_0.png   (5-state: frames 0-4)
│   │   ├── frame_1.png
│   │   └── ...
│   └── SymbolName2/
│       ├── state_off.png (Binary: off/on states)
│       └── state_on.gif
└── SymbolName3/          (or direct symbols at root)
    └── static.png        (Static: single image)</pre>
                    <p style="margin-bottom: 5px;"><strong>Auto-Detection:</strong></p>
                    <ul style="margin: 5px 0;">
                        <li>5-State: Has frame_0.png through frame_4.png</li>
                        <li>Binary: Has state_off.png and state_on.(png/gif)</li>
                        <li>Static: Single image or doesn't match above</li>
                    </ul>
                </div>
                
                <div class="form-group">
                    <label>Select Folder to Process:</label>
                    <input type="file" id="folderInput" webkitdirectory directory multiple style="display: none;">
                    <button class="btn btn-primary" onclick="document.getElementById('folderInput').click()">
                        Choose Folder
                    </button>
                    <div id="folderName" style="margin-top: 10px; color: #666;"></div>
                </div>
                
                <div id="batchPreview" style="display: none;">
                    <h3 style="color: #5e72e4; margin: 20px 0 10px;">Detected Structure:</h3>
                    <div id="detectedStructure" style="background: #f8f9fa; padding: 15px; border-radius: 8px; max-height: 400px; overflow-y: auto;"></div>
                </div>
                
                <button class="btn btn-success" id="batchGenerateBtn" onclick="generateBatchPackage()" style="display: none; width: 100%; padding: 15px; font-size: 18px; margin-top: 20px;">
                    Generate Package from Folders
                </button>
                
                <div class="progress" id="batchProgress">
                    <div class="progress-bar">
                        <div class="progress-fill" id="batchProgressFill">0%</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        let symbols = [];
        let currentSymbolFiles = {};
        let batchFolderData = null;
        
        // Tab switching
        function switchTab(tab) {
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            if (tab === 'single') {
                document.querySelector('.tab-btn:nth-child(1)').classList.add('active');
                document.getElementById('singleTab').classList.add('active');
            } else {
                document.querySelector('.tab-btn:nth-child(2)').classList.add('active');
                document.getElementById('batchTab').classList.add('active');
            }
        }
        
        // Handle structure radio change
        document.querySelectorAll('input[name="structure"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                const useRegions = e.target.value === 'regions';
                document.getElementById('regionsSection').style.display = useRegions ? 'block' : 'none';
                document.getElementById('regionSelectGroup').style.display = useRegions ? 'block' : 'none';
                
                if (useRegions) {
                    updateRegionSelect();
                }
            });
        });
        
        // Update region select when region names change
        document.getElementById('regionNames').addEventListener('input', updateRegionSelect);
        
        function updateRegionSelect() {
            const regionNames = document.getElementById('regionNames').value;
            const select = document.getElementById('regionSelect');
            select.innerHTML = '<option value="">Select Region...</option>';
            
            if (regionNames) {
                const regions = regionNames.split(',').map(r => r.trim()).filter(r => r);
                regions.forEach(region => {
                    select.innerHTML += `<option value="${region}">${region}</option>`;
                });
            }
        }
        
        // Handle animation type change
        document.querySelectorAll('input[name="animType"]').forEach(radio => {
            radio.addEventListener('change', updateStateInputs);
        });
        
        // Initialize state inputs
        updateStateInputs();
        
        function updateStateInputs() {
            const animType = document.querySelector('input[name="animType"]:checked').value;
            const container = document.getElementById('stateInputs');
            container.innerHTML = '';
            
            if (animType === '5state') {
                const states = ['0% (Empty)', '25%', '50%', '75%', '100% (Full)'];
                states.forEach((state, i) => {
                    container.innerHTML += `
                        <div class="state-input-row">
                            <span class="state-label">State ${i} - ${state}:</span>
                            <label class="file-input-label">
                                Choose Image
                                <input type="file" class="file-input" id="state${i}" accept="image/*" onchange="handleFileSelect('state${i}')">
                            </label>
                            <span class="file-name" id="state${i}Name"></span>
                        </div>
                    `;
                });
            } else if (animType === 'binary') {
                container.innerHTML = `
                    <div class="state-input-row">
                        <span class="state-label">Off State:</span>
                        <label class="file-input-label">
                            Choose Image
                            <input type="file" class="file-input" id="stateOff" accept="image/*" onchange="handleFileSelect('stateOff')">
                        </label>
                        <span class="file-name" id="stateOffName"></span>
                    </div>
                    <div class="state-input-row">
                        <span class="state-label">On State:</span>
                        <label class="file-input-label">
                            Choose Image/GIF
                            <input type="file" class="file-input" id="stateOn" accept="image/*,image/gif" onchange="handleFileSelect('stateOn')">
                        </label>
                        <span class="file-name" id="stateOnName"></span>
                    </div>
                `;
            } else {
                container.innerHTML = `
                    <div class="state-input-row">
                        <span class="state-label">Static Image:</span>
                        <label class="file-input-label">
                            Choose Image
                            <input type="file" class="file-input" id="staticImage" accept="image/*" onchange="handleFileSelect('staticImage')">
                        </label>
                        <span class="file-name" id="staticImageName"></span>
                    </div>
                `;
            }
        }
        
        // Handle file selections
        document.getElementById('thumbnail').addEventListener('change', (e) => {
            handleFileSelect('thumbnail');
        });
        
        function handleFileSelect(inputId) {
            const input = document.getElementById(inputId);
            const nameSpan = document.getElementById(inputId + 'Name');
            if (input && input.files && input.files[0]) {
                nameSpan.textContent = input.files[0].name;
                currentSymbolFiles[inputId] = input.files[0];
            }
        }
        
        async function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
        
        async function generateThumbnail(sourceFile) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                canvas.width = 280;
                canvas.height = 280;
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, 280, 280);
                
                const img = new Image();
                img.onload = () => {
                    const scale = Math.min(280 / img.width, 280 / img.height);
                    const w = img.width * scale;
                    const h = img.height * scale;
                    const x = (280 - w) / 2;
                    const y = (280 - h) / 2;
                    
                    ctx.drawImage(img, x, y, w, h);
                    
                    canvas.toBlob(blob => {
                        resolve(blob);
                    }, 'image/png');
                };
                
                if (sourceFile instanceof File) {
                    img.src = URL.createObjectURL(sourceFile);
                } else {
                    img.src = 'data:image/png;base64,' + sourceFile;
                }
            });
        }
        
        async function getImageDimensions(file) {
            return new Promise((resolve, reject) => {
                const url = URL.createObjectURL(file);
                const img = new Image();
                img.onload = () => {
                    URL.revokeObjectURL(url);
                    resolve({ width: img.width, height: img.height });
                };
                img.onerror = reject;
                img.src = url;
            });
        }
        
        async function addSymbol() {
            const name = document.getElementById('symbolName').value;
            const animType = document.querySelector('input[name="animType"]:checked').value;
            const pointName = document.getElementById('pointName').value;
            const structure = document.querySelector('input[name="structure"]:checked').value;
            
            if (!name) {
                alert('Please enter a symbol name');
                return;
            }
            
            let region = '';
            if (structure === 'regions') {
                region = document.getElementById('regionSelect').value;
                if (!region) {
                    alert('Please select a region for this symbol');
                    return;
                }
            }
            
            const symbol = {
                name: name,
                animationType: animType,
                pointName: pointName || name + 'Value',
                region: region,
                thumbnailFile: currentSymbolFiles.thumbnail,
                stateFiles: {}
            };
            
            if (animType === '5state') {
                for (let i = 0; i < 5; i++) {
                    symbol.stateFiles[`state${i}`] = currentSymbolFiles[`state${i}`];
                }
            } else if (animType === 'binary') {
                symbol.stateFiles.off = currentSymbolFiles.stateOff;
                symbol.stateFiles.on = currentSymbolFiles.stateOn;
            } else {
                symbol.stateFiles.static = currentSymbolFiles.staticImage;
            }
            
            symbols.push(symbol);
            updateSymbolsList();
            
            document.getElementById('symbolName').value = '';
            document.getElementById('pointName').value = '';
            currentSymbolFiles = {};
            document.querySelectorAll('.file-name').forEach(span => span.textContent = '');
            updateStateInputs();
        }
        
        function updateSymbolsList() {
            const list = document.getElementById('symbolsList');
            const structure = document.querySelector('input[name="structure"]:checked').value;
            
            if (structure === 'regions') {
                const symbolsByRegion = {};
                symbols.forEach(sym => {
                    if (!symbolsByRegion[sym.region]) {
                        symbolsByRegion[sym.region] = [];
                    }
                    symbolsByRegion[sym.region].push(sym);
                });
                
                list.innerHTML = Object.keys(symbolsByRegion).map(region => `
                    <div style="margin-bottom: 20px;">
                        <h3 style="color: #5e72e4; margin-bottom: 10px;">${region}</h3>
                        ${symbolsByRegion[region].map((sym, i) => {
                            const globalIndex = symbols.indexOf(sym);
                            return `
                                <div class="symbol-card">
                                    <button class="delete-btn" onclick="removeSymbol(${globalIndex})">Delete</button>
                                    <h3>${sym.name}</h3>
                                    <p>Type: ${sym.animationType}</p>
                                    <p>Point: ${sym.pointName}</p>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `).join('');
            } else {
                list.innerHTML = symbols.map((sym, i) => `
                    <div class="symbol-card">
                        <button class="delete-btn" onclick="removeSymbol(${i})">Delete</button>
                        <h3>${sym.name}</h3>
                        <p>Type: ${sym.animationType}</p>
                        <p>Point: ${sym.pointName}</p>
                    </div>
                `).join('');
            }
        }
        
        function removeSymbol(index) {
            symbols.splice(index, 1);
            updateSymbolsList();
        }
        
        async function generatePackage() {
            if (symbols.length === 0) {
                alert('Please add at least one symbol');
                return;
            }
            
            const progress = document.getElementById('progress');
            const progressFill = document.getElementById('progressFill');
            progress.style.display = 'block';
            
            const zip = new JSZip();
            const structure = document.querySelector('input[name="structure"]:checked').value;
            
            if (structure === 'regions') {
                const regions = document.getElementById('regionNames').value.split(',').map(r => r.trim()).filter(r => r);
                zip.file('symbol-packs.json', JSON.stringify(regions));
                
                const symbolsByRegion = {};
                symbols.forEach(sym => {
                    if (!symbolsByRegion[sym.region]) {
                        symbolsByRegion[sym.region] = [];
                    }
                    symbolsByRegion[sym.region].push(sym);
                });
                
                for (const region of regions) {
                    if (symbolsByRegion[region]) {
                        const regionFolder = zip.folder(region);
                        
                        const libraryJson = {
                            symbolCategoryContent: [{
                                title: "",
                                contentList: symbolsByRegion[region].map(sym => ({
                                    name: sym.name,
                                    url: `Thumbnail/${sym.name}.png`,
                                    svgURL: `${sym.name}.html`,
                                    symbolType: sym.animationType === 'static' ? '' : (sym.animationType === 'binary' ? 'binary' : 'numeric'),
                                    dragType: "symbol",
                                    pointBindable: sym.animationType === 'static' ? "false" : "true",
                                    keyData: sym.animationType === 'static' ? [] : [{
                                        KeyName: sym.pointName,
                                        KeyPoint: [sym.animationType === 'binary' ? "BO-V" : "MA-D"]
                                    }]
                                }))
                            }]
                        };
                        
                        regionFolder.file('customSymbolLibrary.json', JSON.stringify(libraryJson, null, 2));
                        
                        const regionAnimatedSymbols = symbolsByRegion[region].filter(s => s.animationType !== 'static');
                        if (regionAnimatedSymbols.length > 0) {
                            const animationsJs = await generateAnimationsJs(regionAnimatedSymbols);
                            regionFolder.file('csAnimations.js', animationsJs);
                        }
                        
                        for (const symbol of symbolsByRegion[region]) {
                            const html = await generateSymbolHtml(symbol);
                            regionFolder.file(`${symbol.name}.html`, html);
                            
                            let thumbnailBlob = symbol.thumbnailFile;
                            if (!thumbnailBlob) {
                                let sourceFile = null;
                                if (symbol.animationType === '5state' && symbol.stateFiles.state0) {
                                    sourceFile = symbol.stateFiles.state0;
                                } else if (symbol.animationType === 'binary' && symbol.stateFiles.off) {
                                    sourceFile = symbol.stateFiles.off;
                                } else if (symbol.animationType === 'static' && symbol.stateFiles.static) {
                                    sourceFile = symbol.stateFiles.static;
                                }
                                
                                if (sourceFile) {
                                    thumbnailBlob = await generateThumbnail(sourceFile);
                                }
                            }
                            
                            if (thumbnailBlob) {
                                regionFolder.folder('Thumbnail').file(`${symbol.name}.png`, thumbnailBlob);
                            }
                        }
                    }
                }
            } else {
                const libraryJson = {
                    symbolCategoryContent: [{
                        title: "",
                        contentList: symbols.map(sym => ({
                            name: sym.name,
                            url: `Symbols/Thumbnail/${sym.name}.png`,
                            svgURL: `${sym.name}.html`,
                            symbolType: sym.animationType === 'static' ? '' : (sym.animationType === 'binary' ? 'binary' : 'numeric'),
                            dragType: "symbol",
                            pointBindable: sym.animationType === 'static' ? "false" : "true",
                            keyData: sym.animationType === 'static' ? [] : [{
                                KeyName: sym.pointName,
                                KeyPoint: [sym.animationType === 'binary' ? "BO-V" : "MA-D"]
                            }]
                        }))
                    }]
                };
                
                zip.file('customSymbolLibrary.json', JSON.stringify(libraryJson, null, 2));
                
                if (symbols.some(s => s.animationType !== 'static')) {
                    const animationsJs = await generateAnimationsJs(symbols);
                    zip.file('csAnimations.js', animationsJs);
                }
                
                for (const symbol of symbols) {
                    const html = await generateSymbolHtml(symbol);
                    zip.file(`${symbol.name}.html`, html);
                    
                    let thumbnailBlob = symbol.thumbnailFile;
                    if (!thumbnailBlob) {
                        let sourceFile = null;
                        if (symbol.animationType === '5state' && symbol.stateFiles.state0) {
                            sourceFile = symbol.stateFiles.state0;
                        } else if (symbol.animationType === 'binary' && symbol.stateFiles.off) {
                            sourceFile = symbol.stateFiles.off;
                        } else if (symbol.animationType === 'static' && symbol.stateFiles.static) {
                            sourceFile = symbol.stateFiles.static;
                        }
                        
                        if (sourceFile) {
                            thumbnailBlob = await generateThumbnail(sourceFile);
                        }
                    }
                    
                    if (thumbnailBlob) {
                        zip.folder('Symbols').folder('Thumbnail').file(`${symbol.name}.png`, thumbnailBlob);
                    }
                }
            }
            
            progressFill.style.width = '100%';
            progressFill.textContent = 'Generating ZIP...';
            
            const content = await zip.generateAsync({type: 'blob'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(content);
            link.download = 'CustomSymbols.zip';
            link.click();
            
            progressFill.textContent = 'Complete!';
            
            setTimeout(() => {
                progress.style.display = 'none';
                progressFill.style.width = '0%';
            }, 2000);
        }
        
        async function generateSymbolHtml(symbol) {
            const jciId = symbol.name.replace(/([A-Z])/g, '_$1').toLowerCase().replace(/^_/, '');
            
            let width = 120;
            let height = 150;
            
            try {
                let firstImageFile = null;
                if (symbol.animationType === '5state' && symbol.stateFiles.state0) {
                    firstImageFile = symbol.stateFiles.state0;
                } else if (symbol.animationType === 'binary' && symbol.stateFiles.off) {
                    firstImageFile = symbol.stateFiles.off;
                } else if (symbol.animationType === 'static' && symbol.stateFiles.static) {
                    firstImageFile = symbol.stateFiles.static;
                }
                
                if (firstImageFile) {
                    const dimensions = await getImageDimensions(firstImageFile);
                    width = dimensions.width;
                    height = dimensions.height;
                }
            } catch (err) {
                console.warn('Could not read image dimensions, using defaults', err);
            }
            
            if (symbol.animationType === '5state') {
                const states = [];
                for (let i = 0; i < 5; i++) {
                    const file = symbol.stateFiles[`state${i}`];
                    const base64 = file ? await fileToBase64(file) : '';
                    states.push(base64);
                }
                
                return `<svg xmlns:jci="http://jci.com" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="${width}px" height="${height}px" viewBox="0 0 ${width} ${height}" style="enable-background:new 0 0 ${width} ${height};" xml:space="preserve" jci-id="${jciId}">
    <g style="pointer-events:none" transform="scale(1.0, 1.0)">
        <image class="state0" style="overflow:visible;" width="${width}" height="${height}" xlink:href="data:image/png;base64,${states[0]}"></image>
        <image class="state1" style="overflow:visible;display:none;" width="${width}" height="${height}" xlink:href="data:image/png;base64,${states[1]}"></image>
        <image class="state2" style="overflow:visible;display:none;" width="${width}" height="${height}" xlink:href="data:image/png;base64,${states[2]}"></image>
        <image class="state3" style="overflow:visible;display:none;" width="${width}" height="${height}" xlink:href="data:image/png;base64,${states[3]}"></image>
        <image class="state4" style="overflow:visible;display:none;" width="${width}" height="${height}" xlink:href="data:image/png;base64,${states[4]}"></image>
        <path style="pointer-events:visible" opacity="0" fill-rule="evenodd" clip-rule="evenodd" d="M10,10 L${width-10},10 L${width-10},${height-10} L10,${height-10} Z" />
    </g>
</svg>`;
            } else if (symbol.animationType === 'binary') {
                const offBase64 = symbol.stateFiles.off ? await fileToBase64(symbol.stateFiles.off) : '';
                const onFile = symbol.stateFiles.on;
                const onBase64 = onFile ? await fileToBase64(onFile) : '';
                const isGif = onFile && onFile.type === 'image/gif';
                
                return `<svg xmlns:jci="http://jci.com" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="${width}px" height="${height}px" viewBox="0 0 ${width} ${height}" style="enable-background:new 0 0 ${width} ${height};" xml:space="preserve" jci-id="${jciId}">
    <g style="pointer-events:none" transform="scale(1.0, 1.0)">
        <image class="stateOff" style="overflow:visible;" width="${width}" height="${height}" xlink:href="data:image/png;base64,${offBase64}"></image>
        <image class="stateOn" style="overflow:visible;display:none;" width="${width}" height="${height}" xlink:href="data:image/${isGif ? 'gif' : 'png'};base64,${onBase64}"></image>
        <path style="pointer-events:visible" opacity="0" fill-rule="evenodd" clip-rule="evenodd" d="M10,10 L${width-10},10 L${width-10},${height-10} L10,${height-10} Z" />
    </g>
</svg>`;
            } else {
                const base64 = symbol.stateFiles.static ? await fileToBase64(symbol.stateFiles.static) : '';
                return `<svg xmlns:jci="http://jci.com" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="${width}px" height="${height}px" viewBox="0 0 ${width} ${height}" style="enable-background:new 0 0 ${width} ${height};" xml:space="preserve" jci-id="${jciId}">
    <g style="pointer-events:none" transform="scale(1.0, 1.0)">
        <image style="overflow:visible;" width="${width}" height="${height}" xlink:href="data:image/png;base64,${base64}"></image>
        <path style="pointer-events:visible" opacity="0" fill-rule="evenodd" clip-rule="evenodd" d="M10,10 L${width-10},10 L${width-10},${height-10} L10,${height-10} Z" />
    </g>
</svg>`;
            }
        }
        
        async function generateAnimationsJs(symbolList = null) {
            const animatedSymbols = (symbolList || symbols).filter(s => s.animationType !== 'static');
            
            let js = '(function () {\n\n';
            
            for (const symbol of animatedSymbols) {
                const jciId = symbol.name.replace(/([A-Z])/g, '_$1').toLowerCase().replace(/^_/, '');
                
                if (symbol.animationType === '5state') {
                    js += `    this.${symbol.name} = function() {
        var points = MUI.Control.SymbolAnimationBase.call(this, 
            "${symbol.name}",
            MUI.SymbolType.Numeric,
            MUI.AnimationType.Img,
            [MUI.StateValuesType.PercentBased4]);
        
        points[0].AnimationSrc = [
            ["Closed", "state0"], 
            ["PerOpen25", "state1"], 
            ["PerOpen50", "state2"],
            ["PerOpen75", "state3"],
            ["PerOpen100", "state4"]
        ];
        
        points[0].PointName = "${symbol.pointName}";
        points[0].MinValueOffState = 0;
        points[0].MaxValueOffState = 100;
        this.SetAnimationPoints(points);
    };\n\n`;
                } else if (symbol.animationType === 'binary') {
                    js += `    this.${symbol.name} = function() {
        var points = MUI.Control.SymbolAnimationBase.call(this,
            "${symbol.name}",
            MUI.SymbolType.Binary,
            MUI.AnimationType.OnOff,
            [MUI.StateValuesType.Boolean]);
        
        points[0].AnimationSrc = [
            ["Off", ".stateOff"],
            ["On", ".stateOn"]
        ];
        
        points[0].PointName = "${symbol.pointName}";
        points[0].MaxValueOffState = 0;
        this.SetAnimationPoints(points);
    };\n\n`;
                }
            }
            
            js += '    var csMapper = MUI.SymbolFactory.MapperObj;\n';
            js += '    var MapItem = MUI.SymbolFactory.MapItemFun;\n\n';
            
            for (const symbol of animatedSymbols) {
                const jciId = symbol.name.replace(/([A-Z])/g, '_$1').toLowerCase().replace(/^_/, '');
                js += `    csMapper.push(new MapItem("${symbol.name}", "${jciId}", this.${symbol.name}));\n`;
            }
            
            js += '\n}.bind({})());';
            
            return js;
        }
        
        // Batch processing functions
        document.getElementById('folderInput').addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;
            
            document.getElementById('folderName').textContent = `Processing ${files.length} files...`;
            
            batchFolderData = await parseFolderStructure(files);
            displayDetectedStructure(batchFolderData);
            
            document.getElementById('batchPreview').style.display = 'block';
            document.getElementById('batchGenerateBtn').style.display = 'block';
        });
        
        async function parseFolderStructure(files) {
            const structure = {
                hasRegions: false,
                regions: {},
                rootSymbols: {}
            };
            
            const filesByPath = {};
            for (const file of files) {
                const pathParts = file.webkitRelativePath.split('/');
                if (pathParts.length < 2) continue;
                
                const key = pathParts.slice(0, -1).join('/');
                if (!filesByPath[key]) filesByPath[key] = [];
                filesByPath[key].push(file);
            }
            
            for (const [path, pathFiles] of Object.entries(filesByPath)) {
                const pathParts = path.split('/');
                
                const imageFiles = pathFiles.filter(f => f.name.match(/\.(png|gif|jpg|jpeg)$/i));
                if (imageFiles.length === 0) continue;
                
                const symbolData = analyzeSymbolFiles(imageFiles);
                if (!symbolData) continue;
                
                if (pathParts.length === 2) {
                    const [rootFolder, secondLevel] = pathParts;
                    
                    const isRegion = Object.keys(filesByPath).some(p => 
                        p.startsWith(rootFolder + '/' + secondLevel + '/') && p !== path
                    );
                    
                    if (isRegion) {
                        structure.hasRegions = true;
                        if (!structure.regions[rootFolder]) {
                            structure.regions[rootFolder] = {};
                        }
                        structure.regions[rootFolder][secondLevel] = {
                            name: secondLevel,
                            ...symbolData,
                            files: imageFiles
                        };
                    } else {
                        structure.rootSymbols[secondLevel] = {
                            name: secondLevel,
                            ...symbolData,
                            files: imageFiles
                        };
                    }
                } else if (pathParts.length === 3) {
                    structure.hasRegions = true;
                    const [rootFolder, region, symbolName] = pathParts;
                    if (!structure.regions[region]) {
                        structure.regions[region] = {};
                    }
                    structure.regions[region][symbolName] = {
                        name: symbolName,
                        ...symbolData,
                        files: imageFiles
                    };
                } else if (pathParts.length === 1) {
                    structure.rootSymbols[pathParts[0]] = {
                        name: pathParts[0],
                        ...symbolData,
                        files: imageFiles
                    };
                }
            }
            
            return structure;
        }
        
        function analyzeSymbolFiles(files) {
            const fileNames = files.map(f => f.name.toLowerCase());
            
            const hasAllFrames = ['frame_0.png', 'frame_1.png', 'frame_2.png', 'frame_3.png', 'frame_4.png']
                .every(frame => fileNames.includes(frame));
            
            if (hasAllFrames) {
                return {
                    type: '5state',
                    frameFiles: {
                        state0: files.find(f => f.name.toLowerCase() === 'frame_0.png'),
                        state1: files.find(f => f.name.toLowerCase() === 'frame_1.png'),
                        state2: files.find(f => f.name.toLowerCase() === 'frame_2.png'),
                        state3: files.find(f => f.name.toLowerCase() === 'frame_3.png'),
                        state4: files.find(f => f.name.toLowerCase() === 'frame_4.png')
                    }
                };
            }
            
            const hasOffState = fileNames.includes('state_off.png');
            const onStateFile = files.find(f => f.name.toLowerCase().startsWith('state_on.'));
            
            if (hasOffState && onStateFile) {
                return {
                    type: 'binary',
                    frameFiles: {
                        off: files.find(f => f.name.toLowerCase() === 'state_off.png'),
                        on: onStateFile
                    }
                };
            }
            
            const staticFile = files.find(f => f.name.match(/\.(png|gif|jpg|jpeg)$/i));
            if (staticFile) {
                return {
                    type: 'static',
                    frameFiles: {
                        static: staticFile
                    }
                };
            }
            
            return null;
        }
        
        function displayDetectedStructure(structure) {
            let html = '';
            
            if (structure.hasRegions) {
                html += '<h4>Detected Regions:</h4>';
                for (const [region, symbols] of Object.entries(structure.regions)) {
                    html += `<div style="margin-left: 20px; margin-bottom: 10px;">
                        <strong>${region}/</strong>
                        <ul style="margin: 5px 0;">`;
                    for (const [name, data] of Object.entries(symbols)) {
                        html += `<li>${name} (${data.type})</li>`;
                    }
                    html += '</ul></div>';
                }
            }
            
            if (Object.keys(structure.rootSymbols).length > 0) {
                html += '<h4>Root Level Symbols:</h4><ul>';
                for (const [name, data] of Object.entries(structure.rootSymbols)) {
                    html += `<li>${name} (${data.type})</li>`;
                }
                html += '</ul>';
            }
            
            document.getElementById('detectedStructure').innerHTML = html;
        }
        
        async function generateBatchPackage() {
            if (!batchFolderData) return;
            
            const progress = document.getElementById('batchProgress');
            const progressFill = document.getElementById('batchProgressFill');
            progress.style.display = 'block';
            
            const zip = new JSZip();
            
            if (batchFolderData.hasRegions) {
                const regionNames = Object.keys(batchFolderData.regions);
                zip.file('symbol-packs.json', JSON.stringify(regionNames));
                
                for (const [region, symbols] of Object.entries(batchFolderData.regions)) {
                    const regionFolder = zip.folder(region);
                    const regionSymbols = [];
                    
                    for (const [name, data] of Object.entries(symbols)) {
                        const symbolObj = await processBatchSymbol(name, data);
                        regionSymbols.push(symbolObj);
                        
                        const html = await generateSymbolHtml(symbolObj);
                        regionFolder.file(`${name}.html`, html);
                        
                        const thumbnailBlob = await generateThumbnailFromBatchData(data);
                        if (thumbnailBlob) {
                            regionFolder.folder('Thumbnail').file(`${name}.png`, thumbnailBlob);
                        }
                    }
                    
                    const libraryJson = createLibraryJson(regionSymbols, true);
                    regionFolder.file('customSymbolLibrary.json', JSON.stringify(libraryJson, null, 2));
                    
                    const animatedSymbols = regionSymbols.filter(s => s.animationType !== 'static');
                    if (animatedSymbols.length > 0) {
                        const animJs = await generateAnimationsJs(animatedSymbols);
                        regionFolder.file('csAnimations.js', animJs);
                    }
                }
            }
            
            if (Object.keys(batchFolderData.rootSymbols).length > 0) {
                const rootSymbols = [];
                
                for (const [name, data] of Object.entries(batchFolderData.rootSymbols)) {
                    const symbolObj = await processBatchSymbol(name, data);
                    rootSymbols.push(symbolObj);
                    
                    const html = await generateSymbolHtml(symbolObj);
                    zip.file(`${name}.html`, html);
                    
                    const thumbnailBlob = await generateThumbnailFromBatchData(data);
                    if (thumbnailBlob) {
                        zip.folder('Symbols').folder('Thumbnail').file(`${name}.png`, thumbnailBlob);
                    }
                }
                
                const libraryJson = createLibraryJson(rootSymbols, false);
                zip.file('customSymbolLibrary.json', JSON.stringify(libraryJson, null, 2));
                
                const animatedSymbols = rootSymbols.filter(s => s.animationType !== 'static');
                if (animatedSymbols.length > 0) {
                    const animJs = await generateAnimationsJs(animatedSymbols);
                    zip.file('csAnimations.js', animJs);
                }
            }
            
            progressFill.style.width = '90%';
            progressFill.textContent = 'Generating ZIP...';
            
            const content = await zip.generateAsync({type: 'blob'});
            const link = document.createElement('a');
            link.href = URL.createObjectURL(content);
            link.download = 'CustomSymbols_Batch.zip';
            link.click();
            
            progressFill.style.width = '100%';
            progressFill.textContent = 'Complete!';
            
            setTimeout(() => {
                progress.style.display = 'none';
                progressFill.style.width = '0%';
            }, 2000);
        }
        
        async function processBatchSymbol(name, data) {
            return {
                name: name,
                animationType: data.type,
                pointName: name,
                region: '',
                thumbnailFile: null,
                stateFiles: data.frameFiles
            };
        }
        
        async function generateThumbnailFromBatchData(data) {
            let sourceFile = null;
            
            if (data.type === '5state' && data.frameFiles.state0) {
                sourceFile = data.frameFiles.state0;
            } else if (data.type === 'binary' && data.frameFiles.off) {
                sourceFile = data.frameFiles.off;
            } else if (data.type === 'static' && data.frameFiles.static) {
                sourceFile = data.frameFiles.static;
            }
            
            if (sourceFile) {
                return await generateThumbnail(sourceFile);
            }
            
            return null;
        }
        
        function createLibraryJson(symbolList, isRegion) {
            return {
                symbolCategoryContent: [{
                    title: "",
                    contentList: symbolList.map(sym => ({
                        name: sym.name,
                        url: isRegion ? `Thumbnail/${sym.name}.png` : `Symbols/Thumbnail/${sym.name}.png`,
                        svgURL: `${sym.name}.html`,
                        symbolType: sym.animationType === 'static' ? '' : (sym.animationType === 'binary' ? 'binary' : 'numeric'),
                        dragType: "symbol",
                        pointBindable: sym.animationType === 'static' ? "false" : "true",
                        keyData: sym.animationType === 'static' ? [] : [{
                            KeyName: sym.pointName,
                            KeyPoint: [sym.animationType === 'binary' ? "BO-V" : "MA-D"]
                        }]
                    }))
                }]
            };
        }
    </script>
</body>
</html>